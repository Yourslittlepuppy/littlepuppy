# DataFrame数据查询 


```python
import numpy as np
import pandas as pd
```

待测数据

```python
a_values = [
    ['小明','male',18,170.1,60,'北京海淀',61],
    ['小华','female',28,160,50,'上海静安',74],
    ['小红','female',22,175,64,'广州天河',59],
    ['小靑','male',31,182,80,'深圳南山',82],
    ['小兰','female',25,165,55,'杭州西湖',98],
]

a = pd.DataFrame(
    a_values,
    index=[1,2,3,4,5],
    columns=['name','sex','age','heigh','weight','address','grade']
)
```

| | name | sex  | age    | heigh | weight | address | grade      |
| ---- | ---- | ------ | ----- | ------ | ------- | -------- | ---- |
| 1    | 小明 | male   | 18    | 170.1  | 60      | 北京海淀 | 61   |
| 2    | 小华 | female | 28    | 160.0  | 50      | 上海静安 | 74   |
| 3    | 小红 | female | 22    | 175.0  | 64      | 广州天河 | 59   |
| 4    | 小靑 | male   | 31    | 182.0  | 80      | 深圳南山 | 82   |
| 5    | 小兰 | female | 25    | 165.0  | 55      | 杭州西湖 | 98   |

### 属性查询

| 操作      | 含义                                          |
| --------- | --------------------------------------------- |
| a.shape   | 表格形状,行数,列数                            |
| a.dtypes  | 列数据类型(每一列的数据类型)                  |
| a.index   | 行索引(a.index.values)                        |
| a.columns | 列索引                                        |
| a.values  | 对象值，二维ndarray数组(除去索引值的全部数据) |

```python
# 数组查询
a.values[0] # 返回第一行的值
a.values[0][5]# 第一行第6列的单元格数据
```

### 整体数据查询

| 操作         | 含义                                         |
| ------------ | -------------------------------------------- |
| a.info()     | 整体信息，查看:数据是否缺失,数据类型是否正确 |
| a.describe() | 整体统计指标                                 |
| a.head(n)    | 前n 行                                       |
| a.tail(n)    | 后n 行                                       |

```python
a.describe()
```

| |age   | heigh     | weight     | grade     |
| ----- | --------- | ---------- | --------- | --------- |
| count (数量) | 5.000000  | 5.000000   | 5.000000  | 5.000000  |
| mean(平均值) | 24.800000 | 170.420000 | 61.800000 | 74.800000 |
| std(标准差) | 5.069517  | 8.560491   | 11.454257 | 16.053037 |
| min(最小值) | 18.000000 | 160.000000 | 50.000000 | 59.000000 |
| 25%(四分位数) | 22.000000 | 165.000000 | 55.000000 | 61.000000 |
| 50%   | 25.000000 | 170.100000 | 60.000000 | 74.000000 |
| 75%   | 28.000000 | 175.000000 | 64.000000 | 82.000000 |
| max(最大值) | 31.000000 | 182.000000 | 80.000000 | 98.000000 |

---

###  内容查询

#### 类列表/字典/ndarray数组的查询方式

功能简陋，一般仅用于查询单列

```python
a.name
a['name'] # 查询单列
a[['name','age']]# 查询多列
a[1:4] # 行查询,可以查询多行,前包后不包
```

### loc/ iloc法查询

```python
a.loc[1]  # 查询单行
a.loc[[1,4]]#  查询多行
a.loc[:,'address']# 查询单列
a.loc[2:] # 查询单行
a.loc[3,'address']# 查询单元格
a.loc[[2,4],: ]# 查询第2 ,4 行所有列
a.loc[[2,4],['name','age']] # 查询多行多列
'_______________________________________'
a.iloc['name']#报错,iloc是按索引序号查询,从 0 开始,且前包后不包
a.iloc[1] # 实际查出的结果是第2行
a.iloc[[1,3],[1,3]] # 查的是第2,4 行,第2 和第4列
'---------------------------------------'
比较iloc  与loc  的区别
a.loc[[2, 4, 5], ['name', 'address']]
a.iloc[[1,3,4], [0, 5]]
```

### 切片查询


```python
a.loc[1:4,:]
a.loc[:,'age':'address']# 切片查询
a.iloc[1:4] # # 完整写法相当于 a.iloc[1:4,:]

```

---

## 索引查询和切片查询的区别
---

* 索引查询更适合查询不连续的行列数据
* 切片查询适合查询连续行和列数据

索引查询可以实现切片查询的所有功能，只是有个书写效率问题

* 用索引查询查连续数据，需要将每个索引都写上，效率低
* 切片查询连续数据，只要写起始和结束索引即可。
    * 切片不能查询不连续数据

### 查询时：优先使用切片查询，无法实现功能时再使用索引查询

___

## 过滤查询

索引查询和切片查询，都是通过索引查询值
通过值查询索引
通过布尔值过滤、筛选数据来查询

* 过滤查询不通过索引，而是通过值查询
* 用于结果索引不确定的查询
* 通过运算所得布尔值对查询结果进行过滤

```python
a[[True, False, True, False, False]] # 使用布尔查询时默认使用的是查询行
```

| |name | sex  | age    | heigh | weight | address | grade    |
| ---- | ---- | ------ | ----- | ------ | ------- | -------- | ---- |
| 1    | 小明 | male   | 18    | 170.1  | 60      | 北京海淀 | 61   |
| 3    | 小红 | female | 22    | 175.0  | 64      | 广州天河 | 59   |

```python
a.loc[[False, True, False, True, False], [True, True, False, False, False, True, False]] # 整个表的数据进行布尔查询,
```

###  自动生成布尔查询条件

例如: 查询所有考试成绩不合格的同学信息

```python
a['greade'] < 60  
>>>
1    False
2    False
3     True
4    False
5    False
Name: grade, dtype: bool
        
a[a['grade']< 60 ]  # 通过查询返回的bool  在进行查找
```

### 将布尔查询和索引、切片查询结合

查询不及格同学的姓名、年龄和考试成绩	

```python
a.loc[a['grade'] < 60, ['name', 'age', 'grade']] # 索引查询
a.loc[a['grade'] < 60, 'name':'age']# 切片查询
```


```python
# 高于平均分的同学
a[a.grade > a.grade.mean()]
```

自定义函数方式查询

```python
# 自定义函数
def good(x):
    return x.grade > x.grade.mean()
good(a)
a[good(a)]# 函数式查询会把前面的表当做参数传入进行每一项匹配,然后输出
```

```python
# 匿名函数
a[lambda x: x.grade > x.grade.mean()]# 返回所有行
a.loc[lambda x: (x.grade > x.grade.mean()) & (x.sex == 'male'), ['name', 'sex', 'grade']] # 组合查询
```

### isin 函数

判断某列是否存在某值,写法简洁

```python
x = a['address'].isin(['北京海淀','深圳南山','美国硅谷'])
# 将查询出的地址进行与后面的进行再次匹配
# 存在则返回True ,不存在则返回False
a[x] # 通过返回的布尔值在继续查询
```

###  逻辑运算
---

    &：且，and
    |：或,or
    -：非(或用 != 判断),not
```python 
x = (a['address'] == '北京海淀') | (a['address'] == '深圳南山') | (a['address'] == '美国硅谷')
a[x]
```

|      | name | sex  | age  | heigh | weight | address  | grade |
| ---- | ---- | ---- | ---- | ----- | ------ | -------- | ----- |
| 1    | 小明 | male | 18   | 170.1 | 60     | 北京海淀 | 61    |
| 4    | 小靑 | male | 31   | 182.0 | 80     | 深圳南山 | 82    |

### where 过滤

举例: 查询所有体重大于60 ,成绩大于60的同学(2个条件)
抽出2列,单独判断布尔值,逻辑运算组合结果

```python
a[(a.weight > 60) & (a.grade > 60)]
```

#### where过滤方式

抽出所有列组合为表格，一次判断，返回结果

```python
b = a[['weight', 'grade']] # 先查出所有要查的值
b[b > 60]
b[b > 60].dropna() # 去除缺失值所在的行
```

### 总结：

* 原生的布尔查询，需要每列单独判断条件，然后用逻辑运算符组合条件，得出最终结果
* where过滤过滤：先将所有需要判断条件的列抽出来，整体判断，得出最终结果
    * 优点：写法简洁
    * 缺点：where过滤所有列的判断条件，只能有一个，使用受限

---

where和mask函数，查询和替换
---

a.where(b > 60, c)

* 当判断条件为True，返回 a
* 当判断条件为False，返回的 c

举例: 考试及格,返回姓名,不及格返回地址

```python
a['grade'] >= 60  # 考试及格为True
a['name'].where(a['grade'] >= 60)  # 及格，返回姓名
a['name'].where(a['grade'] >= 60, a['address'])  # 进阶，不及格，返回地址
```

```python
# 查询不及格同学的信息
a.where(a['grade'] < 60).dropna()  # 删除缺失值行
a[a.grade < 60]  # 等价上面写法
```

### mask相反，布尔值为True的转为缺失值

mask 的操作与where 相反,基本结构一致,mask是where的逆运算

补充: 

## Pandas对象修改的视图模式和副本模式

---

* 视图模式：多个变量指向同一内存数据
    * 修改一个变量，另一个变量值也会变
    * 操作如：将一个对象整体赋值给另一个变量
* 副本模式：每个变量都指向独立的内存数据
    * 修改一个变量，另一个变量值不会变
    * 操作如：将一个对象查询的一部分值赋值给另一个变量

---

* 当将一个对象整体赋值给另一个变量时，**视图模式**，两个变量对应的内存地址相同，修改一个变量，另一个变量也会改变。
* 当使用copy()将一个对象赋值给另一个变量时
    * 或者使用查询赋值，查询数据的一部分并赋值给其他变量
    * 当赋值为原数据查询的一部分时，是**副本模式**，修改一个变量不会影响另一个变量

```python 
a=pd.DataFrame(a_values)
b=a
c=b
# 现在对c进行操作,对某些数据进行更改,直接修改会把整个数据表都修改.不建议
#解决方法一:
b = a.copy()
c.loc[1,'name']= '大佬'
# 这种操作不会对原数据修改
# 解决方法二: 
先查询出部分数据赋值给新的变量.对新的变量进行更改,而不改变原有的数据
系统会提示警告,但不影响修改
```

### 数据删除

数据删除并不是真的删除,会反回一个新的表

```python
# Series 删除
b = a.drop('name') # 需要有一个新的变量接
e.drop('name', inplace=True) # 这就真的删除
```

```python
# DataFrame 删除
* 删除基本等同于简单版的查询
* 默认不修改原值，只输出删除后的数据，真删除加参数 inplace=True
* 默认的参数：axis=0 删除行，改为 axis=1 删除列
# 删除行
f.drop(6)  # 简写
f.drop(6, axis=0)  # 完整写法 
#删除列
f.drop(6, axis=1)
# 真删除
f.drop(['sex', 'address'], axis=1,inplace = 1)  # 删除多列
```

